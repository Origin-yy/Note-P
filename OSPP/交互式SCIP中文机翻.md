#1.1 编程要素

​		一种强大的编程语言不仅仅是一种指示计算机执行任务的方法。 该语言还充当一个框架，我们在其中组织关于流程的想法。 因此，当我们描述一种语言时，我们应该特别注意该语言提供的将简单的想法组合成更复杂的想法的方法。 每一种强大的语言都有三种机制来实现这一点：

+ 原始表达式:  表示语言所涉及的最简单的实体.

+  组合方式:  复合元素由较简单的元素构成.

+  抽象手段:  通过它可以命名复合元素并将其作为单元进行操作。


​		在编程中，我们处理两种元素：过程和数据。 （稍后我们会发现它们实际上并没有那么明显。）通俗地说，数据是我们想要操作的“东西”，而过程是对操作数据的规则的描述。 因此，任何强大的编程语言都应该能够描述原始数据和原始过程，并且应该有组合和抽象过程和数据的方法。

  		在本章中，我们将只处理简单的数值数据，以便我们可以专注于构建程序的规则。 1． 将数字描述为“简单数据”是一种赤裸裸的虚张声势。 事实上，数字的处理是任何编程语言中最棘手和最令人困惑的方面之一。 涉及的一些典型问题如下： 一些计算机系统将整数（例如 2）与实数（例如 2.71）区分开来。 实数 2.00 与整数 2 不同吗？ 用于整数的算术运算与用于实数的运算是否相同？ 6 除以 2 是 3 还是 3.0？ 我们可以代表多大的数字？ 我们可以表示多少位小数的精度？ 整数的取值范围和实数的取值范围一样吗？ 当然，除了这些问题之外，还有一系列关于舍入和截断误差的问题——整个数值分析科学。 由于本书的重点是大规模程序设计而不是数值技术，因此我们将忽略这些问题。 本章中的数值示例将展示在非整数运算中使用保留有限小数位精度的算术运算时观察到的常见舍入行为。 ^1 在后面的章节中，我们将看到这些相同的规则也允许我们构建过程来操作复合数据。

## 1.1.1 表达式

​		开始编程的一种简单方法是检查与 Lisp Scheme 方言的解释器的一些典型交互。 想象一下，您正坐在计算机终端前。 您键入一个表达式，解释器通过显示对该表达式求值的结果来响应。

​		您可能键入的一种原始表达式是数字。（更准确地说，您键入的表达式由表示以 10 为基数的数字组成。）如果您向 Lisp 提供一个数字，解释器将通过打印进行响应。
表示数字的表达式可以与表示原始过程的表达式（例如 + 或 *）组合，形成一个复合表达式，表示将过程应用于这些数字。 例如：

```scheme
Scheme]  (+ 137 349)
486
Scheme]  (- 1000 334)
666
Scheme]  (- 1000 334)
666
Scheme]  (* 5 99)
495
Scheme]  (/ 10 5)
2
Scheme]  (+ 2.7 10)
12.7
Scheme]  
```

诸如此类的表达式，通过在括号内分隔表达式列表以表示过程应用而形成，称为组合。 列表中最左边的元素称为运算符，其他元素称为操作数。 组合的值是通过将运算符指定的过程应用于作为操作数值的参数来获得的。
将运算符放在操作数左侧的约定称为前缀表示法，起初可能会有些混乱，因为它与惯用的数学约定有很大不同。 然而，前缀表示法有几个优点。 其中之一是它可以容纳可能采用任意数量参数的过程，如以下示例所示：

```scheme
Scheme]  (+ 21 35 12 7)
75
Scheme]  (* 25 4 12)
1200
Scheme]  
```

不会出现歧义，因为运算符始终是最左边的元素，并且整个组合由括号分隔。
前缀表示法的第二个优点是它以一种直接的方式扩展以允许嵌套组合，也就是说，具有其元素本身就是组合的组合：

```scheme
Scheme]  (+ (* 3 5) (- 10 6))
19
Scheme]  
```

不会出现歧义，因为运算符始终是最左边的元素，并且整个组合由括号分隔。
前缀表示法的第二个优点是它以一种直接的方式扩展以允许嵌套组合，也就是说，具有其元素本身就是组合的组合：

```scheme
(+ (* 3 (+ (* 2 4) (+ 3 5))) (+ (- 10 7) 6))
```

解释器很容易将其计算为 57。我们可以通过将这样的表达式写成以下形式来帮助自己

```scheme
(+ (* 3
      (+ (* 2 4)
         (+ 3 5)))
   (+ (- 10 7)
      6))
```

遵循一种称为漂亮打印的格式约定，其中编写每个长组合以便操作数垂直对齐。 由此产生的缩进清楚地显示了 expression.1 的结构。 Lisp 系统通常提供帮助用户格式化表达式的功能。 两个特别有用的功能是一个在新行开始时自动缩进到正确的漂亮打印位置，另一个在输入右括号时突出显示匹配的左括号。 
即使是复杂的表达式，解释器也始终在相同的基本循环中运行：它从终端读取表达式，计算表达式，然后打印结果。 这种运行模式通常表示为解释器运行在读取-求值-打印循环中。 请特别注意，没有必要明确指示解释器打印表达式 2 的值。 Lisp 遵循每个表达式都有值的约定。 这个约定，连同 Lisp 作为一种低效语言的旧名声，是 Alan Perlis（转述 Oscar Wilde）的一句俏皮话的来源，“Lisp 程序员知道一切的价值，但不知道任何代价。"

## 1.1.2命名与环境

编程语言的一个关键方面是它提供了使用名称来指代计算对象的方法。 我们说名称标识了一个变量，其值为对象。
在 Lisp 的 Scheme 方言中，我们用 define 命名事物。 键入：

```scheme
Scheme]  (define size 2)
Scheme]  
```

使解释器将值 2 与名称 size 相关联。 [在本书中，我们不显示解释器对评估定义的响应，因为这是高度依赖于实现的。] 一旦名称大小与数字 2 相关联，我们就可以通过名称引用值 2：

```scala
Scheme]  size

2
Scheme]  (* 5 size)

10
Scheme]  

Here are further examples of the use of define:
Scheme]  (define pi 3.14159)

Scheme]  (define radius 10)

Scheme]  (* pi (* radius radius))

314.159
Scheme]  (define circumference (* 2 pi radius))

Scheme]  circumference

62.8318
Scheme]  
```

Define 是我们语言中最简单的抽象方式，因为它允许我们使用简单的名称来指代复合操作的结果，例如上面计算的圆周。 通常，计算对象可能具有非常复杂的结构，每次我们要使用它们时都必须记住并重复它们的细节，这非常不方便。 事实上，复杂的程序是通过逐步构建越来越复杂的计算对象来构建的。 解释器使这种逐步的程序构建变得特别方便，因为可以在连续的交互中逐步创建名称-对象关联。 此功能鼓励程序的增量开发和测试，并且主要负责 Lisp 程序通常由大量相对简单的过程组成的事实。
应该清楚的是，将值与符号相关联并在以后检索它们的可能性意味着解释器必须维护某种记忆以跟踪名称-对象对。 这种记忆称为环境（更准确地说是全局环境，因为我们稍后会看到计算可能涉及许多不同的环境）。[ 第 3 章将展示这种环境概念对于理解解释器如何工作和实现解释器来说都是至关重要的 ]

## 1.1.3 计算组合

我们在本章中的目标之一是隔离关于程序性思考的问题。 作为一个恰当的例子，让我们考虑一下，在计算组合时，解释器本身遵循一个程序。
• 要评估组合，请执行以下操作：

1. 计算组合的子表达式

2. 将作为最左边子表达式（运算符）值的过程应用于作为其他子表达式（操作数）值的参数。

即使是这个简单的规则，也说明了一般流程的一些要点。 首先，观察第一步表明，为了完成组合的计算过程，我们必须首先对组合的每个元素执行计算过程。 因此，计算规则本质上是递归的； 也就是说，作为其步骤之一，它包括调用规则本身的需要。计算规则中说，作为第一步的一部分，我们应该计算组合的最左边的元素，这可能看起来很奇怪，因为此时它只能是一个运算符，例如 + 或 * 代表一个内置的原始过程，例如加法或乘法。 稍后我们将看到，能够处理其运算符本身就是复合表达式的组合是很有用的。
请注意递归的概念可以多么简洁地用于表达在深度嵌套组合的情况下，否则将被视为相当复杂的过程。 例如，计算：

```scheme
(* (+ 2 (* 4 6))
   (+ 3 5 7))
```

要求将计算规则应用于四种不同的组合。 我们可以通过以树的形式表示组合来获得这个过程的图片，如图 1.1 所示。 每个组合都由一个节点表示，该节点具有对应于运算符的分支以及源自它的组合的操作数。 终端节点（即没有分支的节点）代表运算符或数字。从树的角度来看评估，我们可以想象操作数的值向上渗透，从终端节点开始，然后在越来越高的层次上结合。 总的来说，我们将看到递归是一种非常强大的技术，用于处理分层的、树状的对象。 事实上，计算规则的“向上渗透值”形式是一种称为树累积的一般过程的示例。

![image-20230531085235401](/home/origin/.config/Typora/typora-user-images/image-20230531085235401.png)

接下来，观察第一步的重复应用将我们带到需要计算的地步，而不是组合，而是原始表达式，例如数字、内置运算符或其他名称。 我们通过规定来处理原始情况：
• 数字的值是他们命名的数字。
• 内置运算符的值是执行相应操作的机器指令序列。
• 其他名称的值是环境中与这些名称关联的对象。
我们可以将第二条规则视为第三条规则的特例，规定 + 和 * 等符号也包含在全局环境中，并与作为其“值”的机器指令序列相关联。 需要注意的关键点是环境在决定表达式中符号含义方面的作用。 在 Lisp 这样的交互式语言中，如果不指定任何有关环境的信息来为符号 x（甚至符号 +）提供含义，那么谈论表达式（如 (+ x 1)）的值是没有意义的 . 正如我们将在第 3 章中看到的那样，环境作为提供计算发生的上下文的一般概念将在我们理解程序执行方面发挥重要作用。

请注意，上面给出的计算规则不处理定义。 例如，计算 (define x 3) 不会将 define 应用于两个参数，其中一个是符号 x 的值，另一个是 3，因为 define 的目的恰恰是将 x 与一个值相关联。（也就是说，(define x 3) 不是计算。）

一般计算规则的例外形式称为特殊形式。Define 是我们迄今为止看到的唯一一个特殊形式的例子，但我们很快就会遇到其他形式。 每种特殊形式都有自己的计算规则。各种表达式（每个表达式都有其相关的求值规则）构成了编程语言的语法。 与大多数其他编程语言相比，Lisp 的语法非常简单； 也就是说，表达式的求值规则可以用一个简单的通用规则和少量特殊形式的专用规则来描述。[ 特殊的句法形式只是方便的替代表面结构，可以用更统一的方式编写的东西有时被称为句法糖，使用彼得兰丁创造的短语。 与其他语言的用户相比，Lisp 程序员通常不太关心语法问题。 （相比之下，检查任何 Pascal 手册并注意其中有多少专门用于描述语法。）这种对语法的蔑视部分是由于 Lisp 的灵活性，这使得更改表面语法变得容易，部分是由于观察到 许多“方便的”句法结构使语言不那么统一，当程序变得庞大和复杂时，最终会造成更多的麻烦，而不是它们的价值。 用 Alan Perlis 的话来说，“语法糖会导致分号癌。”  ]

## 1.1.4 复合程序

我们已经在 Lisp 中确定了一些必须出现在任何强大的编程语言中的元素：
• 数字和算术运算是原始数据和过程。
• 组合嵌套提供了一种组合操作的方法。
• 将名称与值相关联的定义提供了一种有限的抽象方法。
现在我们将学习过程定义，这是一种更强大的抽象技术，通过它可以给复合操作一个名称，然后将其称为一个单元。
我们首先研究如何表达“平方”的概念。 我们可能会说，“要平方，乘以它本身。” 这在我们的语言中表示为:

```scheme
Scheme]  (define (square x) (* x x))

Scheme]  

```

我们可以这样理解：
(define (square x)    (       *       x          x))
  |            |          |              |        |          |
 To square something, multiply it by itself. 
我们这里有一个复合过程，它被命名为 square。 该过程表示将某物与自身相乘的操作。 要相乘的事物被赋予一个本地名称 x，它与代词在自然语言中所起的作用相同。 计算定义创建了这个复合过程并将其与名称 square 相关联。 [ 请注意，这里组合了两种不同的操作：我们正在创建过程，我们将其命名为 square。 将这两个概念分开是可能的，而且确实很重要——创建过程而不命名它们，并为已经创建的过程命名。 我们将在 1.3.2 中看到如何做到这一点。]
过程定义的一般形式是:

```scheme
(define (⟨name⟩ ⟨formal parameters⟩) ⟨body⟩)
```

⟨name⟩ 是与 environment 中的过程定义相关联的符号。[ 在本书中，我们将通过使用由尖括号分隔的斜体符号来描述表达式的一般语法——例如，⟨name⟩——以表示在实际使用此类表达式时要填充的表达式中的“槽”。] ⟨formal parameters⟩ 是过程主体中使用的名称，用于指代过程的相应参数。 ⟨body⟩ 是一个表达式，当形式参数被应用过程的实际参数替换时，它将产生过程应用程序的值。[ 更一般地说，过程的主体可以是一系列表达式。 在这种情况下，解释器依次计算序列中的每个表达式，并将最终表达式的值作为过程应用程序的值返回。] ⟨name⟩ 和 ⟨formal parameters⟩ 分组在括号内，就像它们在对所定义过程的实际调用中一样。
定义了 square 之后，我们现在可以使用它了：

```scheme
Scheme]  (square 21)

441
Scheme]  (square (+ 2 5))

49
Scheme]  (square (square 3))

81
Scheme]  

```

我们还可以使用 square 作为构建块来定义其他过程。 例如，x^2 + y^2 可以表示为

```scheme
(+ (square x) (square y))
```

我们可以很容易地定义一个过程平方和，给定任何两个数字作为参数，产生它们的平方和：

```scheme
Scheme]  (define (sum-of-squares x y)
  (+ (square x) (square y)))

Scheme]  (sum-of-squares 3 4)

25
Scheme]  

```

现在我们可以使用平方和作为构造块来构造进一步的过程：

```scheme
Scheme]  (define (f a)
  (sum-of-squares (+ a 1) (* a 2)))

Scheme]  (f 5)

136
Scheme]  

```

复合过程的使用方式与原始过程完全相同。 事实上，通过查看上面给出的平方和的定义，我们无法判断 square 是像 + 和 * 一样内置在解释器中，还是被定义为复合过程。

## 1.1.5 程序申请的替代模型

为了计算运算符命名复合过程的组合，解释器遵循与我们在 1.1.3 中描述的运算符命名原始过程的组合大致相同的过程。 也就是说，解释器计算组合的元素并将过程（组合运算符的值）应用于参数（组合操作数的值）。
我们可以假设将原始过程应用于参数的机制内置于解释器中。 对于复合程序，申请流程如下：
• 要将复合过程应用于参数，请用相应的参数替换每个形式参数来计算过程的主体。
为了说明这个过程，让我们计算组合
`（f 5）`
其中 f 是 1.1.4 中定义的过程。 我们首先检索 f 的主体：
`(sum-of-squares (+ a 1) (* a 2))`
然后我们将形参 a 替换为实参 5：
`(sum-of-squares (+ 5 1) (* 5 2))`
因此，问题简化为对具有两个操作数和运算符平方和的组合的计算。 计算这种组合涉及三个子问题。 我们必须计算运算符以获得要应用的过程，我们必须计算操作数以获得参数。 现在 (+ 5 1) 产生 6 而 (* 5 2) 产生 10，所以我们必须对 6 和 10 应用平方和过程。这些值被替换为 sum- 主体中的形式参数 x 和 y of-squares，将表达式简化为
`(+ (square 6) (square 10))`
如果我们使用正方形的定义，这将简化为
`(+ (* 6 6) (* 10 10))`
通过乘法减少到
`(+ 36 100)`
最后到
`136`
我们刚才描述的过程称为过程应用程序的替代模型。 就本章的程序而言，它可以作为决定程序应用“意义”的模型。 但是，有两点需要强调：
+ 替换的目的是帮助我们思考过程应用，而不是提供解释器真正工作原理的描述。 典型的解释器不会通过操纵过程的文本来替换形式参数的值来计算过程应用程序。 实际上，“替换”是通过对形式参数使用本地环境来完成的。 我们将在第 3 章和第 4 章详细检查解释器的实现时更全面地讨论这一点。
+ 在本书的学习过程中，我们将展示一系列越来越精细的解释器如何工作的模型，最终在第 5 章完成解释器和编译器的完整实现。替换模型只是这些模型中的第一个——一种方法开始正式考虑计算过程。 通常，在对科学和工程中的现象进行建模时，我们从简化的、不完整的模型开始。 当我们更详细地检查事物时，这些简单的模型变得不充分，必须用更精细的模型代替。 替代模型也不例外。 特别是，当我们在第 3 章讨论带有“可变数据”的过程的使用时，我们将看到替代模型失效，必须用更复杂的过程应用模型代替。[ 尽管替换的想法很简单，但要对替换过程给出严格的数学定义却出奇地复杂。 问题产生于过程的形式参数使用的名称与过程可能应用到的表达式中使用的（可能相同的）名称之间的可能性混淆。 事实上，在逻辑和编程语义的文献中错误定义替换的历史由来已久。 有关替代的详细讨论，请参见 Stoy 1977。 ]

### 适用顺序与正常顺序
根据 1.1.3 中给出的评估描述，解释器首先计算运算符和操作数，然后将结果过程应用于结果参数。 这不是执行计算的唯一方法。 在需要它们的值之前，替代计算模型不会计算操作数。 相反，它会首先用操作数表达式代替参数，直到它获得一个只包含基本运算符的表达式，然后再执行求值。 如果我们使用这种方法，(f 5) 的评估将根据展开的顺序进行：

```scheme
(sum-of-squares (+ 5 1) (* 5 2))

(+ (square (+ 5 1))    (square (* 5 2)))

(+ (* (+ 5 1) (+ 5 1)) (* (* 5 2) (* 5 2)))
```

继续减少：

```scheme
(+ (* 6 6)              (* 10 10))

(+ 36                   100)
136
```

这给出了与我们之前的计算模型相同的答案，但过程不同。 特别是，(+ 5 1) 和 (* 5 2) 的计算在这里分别执行两次，对应于表达式 (* x x) 的缩减，x 分别被 (+ 5 1) 和 (* 5 2) 替换 。

这种替代的“完全扩展然后减少”计算方法被称为正常顺序计算，解释器实际使用的“计算参数然后应用”方法称为应用顺序计算。 可以证明，对于可以使用替换建模的过程应用程序（包括本书前两章中的所有过程）并产生合法值，正常顺序和应用顺序评估产生相同的值。 （请参阅练习 1.5，了解正常顺序和应用顺序评估不会给出相同结果的“非法”值的实例。）

Lisp 使用应用顺序求值，部分原因是通过避免对表达式的多次求值获得额外的效率，例如上面用 (+ 5 1) 和 (* 5 2) 说明的表达式，更重要的是，因为正常顺序求值变得更加高效 当我们离开可以通过替换建模的程序领域时，处理起来会很复杂。 另一方面，正常顺序计算可能是一个非常有价值的工具，我们将在第 3 章和第 4.1 章中研究它的一些含义。[ 在第 3 章中，我们将介绍流处理，这是一种通过合并有限形式的正常顺序计算来处理明显“无限”数据结构的方法。 在 4.2 中，我们将修改 Scheme 解释器以生成 Scheme 的正常顺序变体。]

## 1.1.6 条件表达式和谓词

此时我们可以定义的过程类的表达能力非常有限，因为我们无法进行测试并根据测试结果执行不同的操作。 例如，我们不能定义一个过程来计算一个数的绝对值，方法是测试数字是正数、负数还是零，并根据规则在不同情况下采取不同的动作

```
|x|={ x  if x>0,
    { 0  if x=0,
    { -x if x<0.
```

这种构造称为案例分析，在 Lisp 中有一种特殊的形式来标记这种案例分析。 它称为 cond（代表“条件”），其用法如下：

```scheme
(define (abs x)
  (cond ((> x 0) x)
        ((= x 0) 0)
        ((< x 0) (- x))))
```

条件表达式的一般形式是:

```scheme
(cond (⟨p_1⟩ ⟨e_1⟩)
      (⟨p_2⟩ ⟨e_2⟩)
      …
      (⟨p_n⟩ ⟨e_n⟩))
```

由符号 cond 后跟带括号的表达式对组成:

```scheme
(⟨p⟩ ⟨e⟩) 
```

称为从句。 每对中的第一个表达式是一个谓词，即一个表达式，其值被解释为 true 或 false。[ “解释为 true 或 false”的意思是：在 Scheme 中，有两个不同的值，用常量 #t 和 #f 表示。 当解释器检查谓词的值时，它会将 #f 解释为假。 任何其他值都被视为 true。 （因此，提供 #t 在逻辑上是不必要的，但它很方便。）在本书中，我们将使用名称 true 和 false，它们分别与值 #t 和 #f 相关联。 ]

条件表达式的计算如下。 首先评估谓词 ⟨p_1⟩。 如果其值为 false，则评估 ⟨p_2⟩。 如果 ⟨p_2⟩ 的值也为 false，则评估 ⟨p_3⟩。 这个过程一直持续到找到一个值为真的谓词，在这种情况下，解释器返回子句相应后置表达式⟨e⟩的值作为条件表达式的值。 如果发现 ⟨p⟩ 都不为真，则 cond 的值未定义。

谓词一词用于返回 true 或 false 的过程，以及计算结果为 true 或 false 的表达式。 绝对值过程 abs 使用原始谓词 >、< 和 =。[ Abs 还使用“减号”运算符 -，当它与单个操作数一起使用时，如 (- x)，表示否定。 ^2 它们将两个数字作为参数，分别测试第一个数字是否大于、小于或等于第二个数字，并相应地返回 true 或 false。]

编写绝对值过程的另一种方法是:

```scheme
(define (abs x)
  (cond ((< x 0) (- x))
  (else x)))
```

可以表达为“如果 x 小于零，则返回 -x； 否则返回 x。” else 是一个特殊符号，可以用来代替 cond 的最后一个子句中的 ⟨p⟩。 这会导致 cond 在绕过所有先前的子句时返回对应的 ⟨e⟩ 的值作为其值。 事实上，任何始终计算为真值的表达式都可以用作此处的 ⟨p⟩。

这是编写绝对值过程的另一种方法：

```scheme
(define (abs x)
(if (< x 0)  
    (- x)
    x))
```

这使用特殊形式 if，一种受限制的条件类型，可以在案例分析中恰好有两个案例时使用。 if 表达式的一般形式是:

`(if ⟨predicate⟩ ⟨consequent⟩ ⟨alternative⟩) `

为了评估 if 表达式，解释器首先评估表达式的 ⟨predicate⟩ 部分。 如果 ⟨predicate⟩ 的计算结果为真值，则解释器随后计算 ⟨consequent⟩ 并返回其值。 否则它计算 ⟨alternative⟩ 并返回它的值 。[ if 和 cond 之间的一个小区别是每个 cond 子句的 ⟨e⟩ 部分可能是一系列表达式。 如果发现对应的 ⟨p⟩ 为真，则表达式 ⟨e⟩ 按顺序求值，并将序列中最后一个表达式的值作为 cond 的值返回。 然而，在 if 表达式中，⟨consequent⟩ 和 ⟨alternative⟩ 必须是单个表达式。]

除了<、=、>等原始谓词外，还有逻辑组合操作，使我们能够构造复合谓词。 最常用的三个是：

`(and ⟨e_1⟩……⟨e_1⟩)`

解释器按从左到右的顺序一次计算一个表达式⟨e⟩。 如果任何 ⟨e⟩ 的计算结果为 false，则 and 表达式的值为 false，其余的 ⟨e⟩ 将不会被计算。 如果所有 ⟨e⟩ 的计算结果为真值，则 and 表达式的值是最后一个的值。

`(or ⟨e_1⟩ ... ⟨e_2⟩)`

解释器按从左到右的顺序一次计算一个表达式⟨e⟩。 如果任何 ⟨e⟩ 的计算结果为真值，则该值作为 or 表达式的值返回，而其余的 ⟨e⟩ 则不计算。 如果所有 ⟨e⟩ 的计算结果为假，则 or 表达式的值为假。

`(not ⟨e⟩)`

当表达式 ⟨e⟩ 的计算结果为 false 时，not 表达式的值为 true，否则为 false。
请注意 and 和 or 是特殊形式，而不是过程，因为子表达式不一定都被求值。 不是普通程序。
作为如何使用它们的示例，数字 x 在 5<x<10 范围内的条件可以表示为

`(and (> x 5) (< x 10))`

作为另一个例子，我们可以定义一个谓词来测试一个数字是否大于或等于另一个数字:

```scheme
(define (>= x y)
  (or (> x y) (= x y)))
```

或者作为:

```scheme
(define (>= x y)
  (not (< x y)))
```

练习 1.1. 下面是一系列表达式。 解释器响应每个表达式打印的结果是什么？ 假设序列将按照它出现的顺序进行评估。

```scheme
Scheme]  10

Scheme]  (+ 5 3 4)

Scheme]  (- 9 1)

Scheme]  (/ 6 2)

Scheme]  (+ (* 2 4) (- 4 6))

Scheme]  (define a 3)

Scheme]  (define b (+ a 1))

Scheme]  (+ a b (* a b))

Scheme]  (= a b)

Scheme]  (if (and (> b a) (< b (* a b)))
    b
    a)

Scheme]  (cond ((= a 4) 6)
      ((= b 4) (+ 6 7 a))
      (else 25))

Scheme]  (+ 2 (if (> b a) b a))

Scheme]  (* (cond ((> a b) a)
         ((< a b) b)
         (else -1)))

Scheme]  

```

练习 1.2. 将以下表达式翻译成前缀形式：(5+4+(2-(3-(6+4/5))))/(3(6-2)(2-7))。
练习 1.3. 定义一个过程，它将三个数字作为参数并返回两个较大数字的平方和。
练习 1.4. 观察我们的评估模型允许运算符为复合表达式的组合。 使用此观察来描述以下过程的行为：

```scheme
(define (a-plus-abs-b a b)
  ((if (> b 0) + -) a b))
```

练习 1.5. Ben Bitdiddle 发明了一个测试来确定他所面对的解释器是使用应用顺序评估还是正常顺序评估。 他定义了以下两个过程：

```scheme
(define (p) (p))

(define (test x y)
  (if (= x 0)
      0
      y))
```

然后计算表达式

```scheme
(test 0 (p))
```

对于使用应用顺序评估的解释器，Ben 会观察到什么行为？ 对于使用正常顺序评估的解释器，他会观察到什么行为？ 解释你的答案。 （假设无论解释器使用正常顺序还是应用顺序，特殊形式 if 的求值规则都是相同的：谓词表达式首先求值，结果决定是求值后件表达式还是替代表达式。）







