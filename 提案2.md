## Project Description

### Description

目前 rFaaS 直接使用 Lbverbs 的 API 进行 RDMA 操作来实现高性能、低延迟的远程内存访问。但是 IBverbs 的 API 所支持的网络类型有限，为了支持其他类型的网络协议，我们需要使用更高级的通信库 Libfabric 来进行 RDMA 操作，同时兼容原有的 IBverbs 实现。该项目有两个主要目标：

1. 将现有代码库重构为使用 IBverbs 和 Libfabric 的兼容实现。
2. 通过调整 TCP 和 AWS EFA 等协议的 Libfabric 配置来支持更多种类的网络。

This link has a more detailed description [click](https://github.com/spcl/.github/blob/main/profile/gsoc.md#rfaas-libfabric-for-fast-function-invocations).

## The Scope of Work

+ 熟悉C/C++。
+ 熟悉 RDMA 操作，如注册注销内存区域、创建和销毁QP、发起和接收数据传输请求、错误处理等。
+ 熟悉不同的网络协议的工作原理和应用场景，如InfiniBand、RoCE、TCP/IP、WAS EFA。
+ 熟悉如何使用 Libfabric 库和 IBverbs 进行 RDMA 操作。
+ 熟悉 sockets provider、EFA provider 的库的配置和使用。
+ 熟悉 Libfabric 和 IBverbs 之间的异同，结合使用两个库的接口完成 RDMA 操作。
+ 熟悉测试的编写和使用，进行优化，保证代码的可靠性和性能。

### Complexity

+ Libfabric API 多而复杂，学习难度大。
+ 不同的网络协议有各自的特点，涉及范围广。
+ IBverbs 和 Libfabric 的 API 的接口有很大的不同，需要仔细处理两者的兼容性问题。
+ 使用不同的网络协议时所需要进行的 Libfabric 具体操作并不完全相同，需要处理好这些不同。
+ 性能的优化，需要根据众多不同的应用场景来选取最优的结局方案来保证性能。
+ 可靠性的保证，修改后的代码支持多种不同的网络协议和 RDMA 适配器，如何进行错误处理，保证程序的可靠性需要仔细考虑。

### Related Work

MVAPICH2是一个基于MPI（Message Passing Interface）的高性能计算通信库。MVAPICH2有一个名为CCH3的通用抽象层可以与不同的底层网络驱动程序交互。它在 InfiniBand 和 RoCE 网络上使用 verbs provider 和 IBverbs，在其他网络上使用 ofi provider 和 Libfabric 。

### Project Proposal

与MVAPICH2类似，我们可以将现有的 IBverbs 接口修改为一个抽象的网络通信 API 接口，让程序直接掉调用这个 API 接口来进行网络通信。

在新的抽象层中，我们完成 IBverbs 和 Libfabric 的两个实现。我们可以利用现有的结构和 IBverbs 实现，在此基础上修改调用接口并在接口内添加 Libfaric 实现。当使用 InfiniBand 和 RoCE 网络时，我们使用原有的 IBverbs 实现，当使用 其他网络时，我们使用新添加的 Libfabric 实现。

对于添加 Libfabric 的方法，我们可以使用抽象基类和子类、模板类和特化、条件编译和宏的方法，他们各有优劣。我们可以根据需要选择实现方式。目前我们仅需要实现 IBverbs 和 Libfabric 两种实现，同时将来对新网络类型的支持也可以使用 Libfabric provider 的方式，并且我们对性能的要求也比较高。虽然这样可能导致代码的冗余和膨胀，增加编译时间和内存消，但基于上面的原因我仍认为模板类和特化的方式更加适合一点。也可以后面的具体需求考虑其他方式，但接下来的方案以模板类和特化方式为主。

具体流程如下：

1. 首先以 GNI 作为 Libfabric provider 进行 Libfabric 实现的编写，保证对 Cray GNI 网络的支持。

2. 对于大多数现有的 API 接口，如 Connection 类，我们需要对它们进行如下修改：

   + 把现有类修改为一个模板类，把参数修改为一个T类型的参数。
   + 当使用 InfiniBand 和 RoCE 网络，针对现有 IBverbs 接口的参数，特化模板类，把T类型的参数转化为所需的多个参数。将现有的 IBverbs 实现进行迁移，完成使用 IBverbs 实现。
   + 当使用其他网络类型时，针对要添加的 Libfabric 接口的参数，特化模板类，把T类型的参数转化为所需的多个参数。使用 GNI provider ，针对其进行 fabric 配置和初始化。利用现有 libfabric 分支已实现的一些网络通信操作，使用 Libfabric 和 GNI provider 特有的接口完成新的 Libfabric 实现。
   + 使用gtest进行单元测试，验证类的正确性和性能，进行优化。

3. 由于 IBverbs 和 Libfabric 提供的 API 的不同、在资源操纵方式上的差异和现有实现大多针对 IBverbs ，因此我认为我们可能需要将少部分 Libfabric 代码独立出来，更好地管理 Libfabric ，这样不仅可以保证代码的可读性，也便于以后对其他网络类型的支持。例如，对 Libfabric 特有的一些抽象资源的管理，如endpoint、domain、transmit context等。

4. 增加使用 GNI provier 的 Libfabric 的其他代码，保证完整功能的实现，主要包括：

   + 所需资源和变量的存储。

   + fabric 配置和初始化，如 fabric域、domain、endpoint等。
   + 基本的网络通信功能：主动发起连接和被动接受连接，断开连接、内存注册、收发数据和消息、读取事件、批量接收、批量发布发送、轮询队列等。
   + 端点，队列等资源的释放。

5. 修改程序的调用接口，进行测试和优化，保证功能的完整、可靠性和性能。

6. 对 Libfabric 实现进行修改，调整 Libfabric 配置来支持 TCP 或 AWS EFA 等更多种类的网络。主要包括：

   + 增加使用新的头文件和库依赖。
   + 增加新的 fabric 初始化和配置流程

   + 增加使用 TCP 等传输模型，使用 TCP provider 和  EFA provider 作为底层网络传输层。
   + 增加使用针对 TCP 和 EFA 的 API 和数据结构，如 struct tcpx_ep 、struct efa_ep。
   + 增加使用针对 TCP 和 EFA 的内存资源管理方法，如`tcpx_xfer_entry_alloc()`、`efa_mr_cache_regattr()`。
   + 增加使用新的 API 调用，如`fi_sendmsg()`,`fi_recvmsg()`.

7. 在新的网络环境下进行测试，对代码进行优化，保证可靠性和性能。

以下是可能要进行的主要的模板类特化：

| 原有代码       | 现有作用                                                     | Libfabric特化类                                              | 可能用到的 API                                               |
| -------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| Address class  | 获取可用的 fablic provider<br />表示RDMA连接的地址，包括IP和端口。 | 移除`fi_getinfo()`,fi_fabric()`等初始化操作，将这部分功能集成到新 Fablic 类中。<br />存储使用资源和变量，初始化所需参数。<br />使用 [fi_av_set](https://ofiwg.github.io/Libfabric/v1.17.1/man/fi_av_set.3.html) 内的 API 和 [fi_av](https://ofiwg.github.io/Libfabric/v1.17.1/man/fi_av.3.html) 内的 API 完成iIP地址和端口的管理。 | `fi_av_open()`,`fi_close()`<br />`fi_av_bind()`,`fi_av_insert()` <br />`fi_av_set() `,` fi_close`()... |
| RDMAActive 类  | 进行 fablic 的相关资源的初始化<br />主动连接到另一个节点。<br />关闭连接。 | 移除 fablic 资源初始化的操作，将这部分功能集成到新 Fablic 类中。<br />存储所需要用的结构体和变量信息，初始化参数。<br />主要使用 [fi_cm](https://ofiwg.github.io/Libfabric/v1.17.1/man/fi_cm.3.html) 内的 API 完成建立连接、返回端点和连接信息的操作。 | `fi_connect()`,`fi_close()`<br />`fi_getpeer()`...           |
| RDMAPassive 类 | 进行 fablic 初始化<br />监听和关闭监听<br />被动接收来自其他节点的连接请求。 | 移除`fi_domain()`操作，将这部分功能集成到新 Fablic 类中。<br />主要使用 [fi_cm](https://ofiwg.github.io/Libfabric/v1.17.1/man/fi_cm.3.html) 内的 API，辅以  [fi_cntr](https://ofiwg.github.io/libfabric/v1.17.1/man/fi_cntr.3.html), [fi_eq](https://ofiwg.github.io/libfabric/v1.17.1/man/fi_eq.3.html), [fi_cq](https://ofiwg.github.io/libfabric/v1.17.1/man/fi_cq.3.html) 内的 API 完成建立连接、返回端点和连接信息的操作。 | `fi_listen()`,`fi_accept()`<br />`fi_pep_bind()`,`fi_eq_open()`<br />`fi_shutdown()`,`fi_close()`... |
| Connection 类  | 使用 Libfabric 或IBverbs 进行 RDMA 通信，包括：<br />初始化、发布/接收消息、轮询事件、关闭连接、批量接收、发布写入和原子操作等通信功能。 | 存储使用资源和变量，初始化所需参数。<br />主要使用 [fi_tagged](https://ofiwg.github.io/Libfabric/v1.17.1/man/fi_tagged.3.html) 内的 API 和 [fi_msg](https://ofiwg.github.io/Libfabric/v1.17.1/man/fi_msg.3.html) 内的 API完成发布缓冲区以接收传入消息和发起发送消息的操作。<br />主要使用 [fi_rma](https://ofiwg.github.io/Libfabric/v1.17.1/man/fi_rma.3.html) 内的 API 完成远程内存读写操作。<br />主要使用 [fi_poll](https://ofiwg.github.io/Libfabric/v1.17.1/man/fi_poll.3.html) 内的 API来完成轮询事件操作。<br />主要使用 [fi_atomic](https://ofiwg.github.io/Libfabric/v1.17.1/man/fi_atomic.3.html) 内的 API完成对远程内存的原子操作。<br />使用 [fi_cq](https://ofiwg.github.io/libfabric/v1.17.1/man/fi_cq.3.html) [fi_cntr](https://ofiwg.github.io/libfabric/v1.17.1/man/fi_cntr.3.html) 内的 API 辅助完成上述操作。 | `fi_trecv`() ,`fi_tsend`() <br />`fi_recv()`  ,`fi_recvv()`<br />`fi_send()`,`fi_sendv()`<br />`fi_read()`<br />`fi_write()`,`fi_readv()`<br />`fi_writev()`,`fi_poll_open()`<br />`fi_poll`(),`fi_wait()`<br />`fi_atomicv()`<br />`post_atomic_fadd（）`... |
| Buffer 类      | 管理本地和远程内存的注册和注销。                             | 存储使用资源和变量，初始化所需参数。<br />使用 [fi_mr](https://ofiwg.github.io/Libfabric/v1.17.1/man/fi_mr.3.html) 内的 API来完成本地和远程内存的管理。 | `fi_mr_reg`(),`fi_close()`<br />`fi_mr_key()`,`fi_mr_raw_attr`()<br />`fi_mr_refresh()`... |

目前我的想法是应该把获取可用的provider信息、 fabric 初始化、资源初始化和部分资源控制的操作独立出来作为新的 Fablic 类，如fablic域、domain、endpoint、计数器、完成队列和事件队列的创建、初始化、控制等。现在的实现将这些操作分散在 Address 类、RDMAActive 类、RDMAPassive类、Connection 类中，我认为这不利于统一管理。但具体操作还需要慎重考虑。

以下是可能需要进行的代码添加：

| 新增代码 | 作用                                                         | 主要实现方式                                                 | 可能用到的 API                                               |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| Fabric类 | 储存支持的网路协议、可使用的 provider 、选择的适配器、fabric 对象、domain 对象、endpoint 对象、计数器、事件队列、完成队列等信息。<br />获取[fi_info](https://ofiwg.github.io/Libfabric/v1.17.1/man/fi_getinfo.3.html#:~:text=FI_INFO-,struct%20fi_info,-%7B%0A%09struct%20fi_info)结构和其中保存的信息。<br />创建/关闭/管理 fabric 对象、domain 对象、endpoint 对象以及其他相关操作。<br />操作计数器、事件队列、完成队列。 | 使用 [fi_getinfo](https://ofiwg.github.io/Libfabric/v1.17.1/man/fi_getinfo.3.html) 内的 API获取可用的 provider 信息。<br />使用 [fi_fabric](https://ofiwg.github.io/Libfabric/v1.17.1/man/fi_fabric.3.html), [fi_domain](https://ofiwg.github.io/libfabric/v1.17.1/man/fi_domain.3.html) 和 [fi_endpoint](https://ofiwg.github.io/Libfabric/v1.17.1/man/fi_endpoint.3.html) 内的 API完成 fabric 对象、domain 对象和 endpoint 的创建和关闭等操作。<br />使用 [fi_cntr](https://ofiwg.github.io/libfabric/v1.17.1/man/fi_cntr.3.html), [fi_cq](https://ofiwg.github.io/libfabric/v1.17.1/man/fi_cq.3.html) 和 [fi_cq](https://ofiwg.github.io/libfabric/v1.17.1/man/fi_cq.3.html) 内的 API 完成对计数器、事件队列、完成队列的创建和操作。 | `fi_getinfo`(),`fi_fabric()` <br />`fi_close()`,`fi_domain()`<br />`fi_endpoint()`,`fi_ep_bind()`<br />`fi_cntr_open()`,`fi_enable`()<br />`fi_cq_open()`,`fi_eq_open`()... |

除了上面这些代码之外，还有一些其他的代码需要修改，例如服务器、客户端、executor 远程函数调用执行器、fast_executor 函数计算服务程序等。在这代码中，当使用 libfabric 时需要把他们使用的 API 和变量换成 Libfabric API 和 Libfabric 变量。需要注意的是，对于不同的 provider ，他们对资源的控制能力并不相同，所用到的 Libfabric API 也不相同。

### Timeline

| Week |           Dates           | Work                                                         |
| ---- | :-----------------------: | :----------------------------------------------------------- |
| 0    |       Before May 29       | 熟悉项目，继续为项目提交PR，做出贡献。继续阅读 [Libfabric man pages](https://ofiwg.github.io/libfabric/v1.17.1/man/) 掌握 Libfabric API 的使用，了解 IBverbs 的使用，细化项目框架和具体代码的实现。了解 Cray GNI 网络、TCP、AWS EFI 网络的实现原理和相关知识和对应 libfabric provider 的 API。做好编写代码的准备。 |
| 1    |    May 29th ~ June 4th    | 添加 Fabric 类。<br />测试：通过 gtest 单元测试。            |
| 2    |   June 5th ~ June 11th    | 重构 RDMAActive 类。<br />测试：通过 gtest 单元测试。        |
| 3    |   June 12th ~ June 18th   | 重构 RDMAPassive 类。<br />测试：通过 gtest 单元测试。       |
| 4    |   June 19th ~ June 25th   | 重构 Connection 类，完成 发布/接收消息和批量接收、发布写入功能。<br />测试：通过 gtest 测试。 |
| 5    |   June 26th ~ July 2nd    | 继续重构 Connection 类，完成轮询事件、原子操作等功能。<br />测试：通过 gtest 测试。 |
| 6    |   July 3rd ～ July 9th    | 重构 Buffer 类。<br />测试：通过 gtest 单元测试。            |
| 7    |   July 10th ~ July 16th   | 对服务器、客户端、executor 远程函数调用执行器、fast_executor 函数计算服务程序的 API 调用部分进行修改，完善程序的整体功能，对可能出现的错误进行处理。<br />测试：程序可以进行正常运行并完成网络通信。 |
| 8    |   July 17th ~ July 23th   | 修改 warm_benchmark、parallel_invocations 等测试程序，对 Cray GNI 网络下的网络通信进行测试并优化性能。<br />测试：通过所有测试并保证性能和可靠性。 |
| 9    |   July 24th ~ July 30th   | 增加 TCP provider 和 EFI provider 的资源初始化和环境配置，为 Fabric 类、RDMAActive 类和 RDMAPassive 类添加新的代码。<br />测试：通过 gtest 测试。 |
| 10   |  July 31th ~ August 6th   | 为 Connection 类和 Buffer 类添加新的代码。<br />测试：通过 gtest 测试。 |
| 11   | August 7th ~ August 13th  | 对程序其他部分进行修改，完善程序的整体功能，对可能出现的错误进行处理。<br />测试：程序能够在 TCP 和 AWS EFI 网络下正常运行。 |
| 12   | August 14th ~ August 20th | 修改 warm_benchmark、parallel_invocations 等测试程序，对  TCP 和 AWS EFI 的网络下的通信进行测试并优化性能。<br />测试：通过所有测试并保证性能和可靠性。 |

#### Buffer Time (8 days)

Allow for a buffer period of 8 days as a safety net, in case anything does not go as planned.

## About me

### Personal Information

● Name: Ye Yuan
● Major: Network Engineering
● University: Xi'an University of Posts
● Degree: Undergraduate sophomore
● Email: origin020726@gmail.com
● Github: https://github.com/Origin-yy
● TimeZone: Shanghai, China (GMT+8)

###Schedule

在学校放暑假（大约7月15日）之前，除了学校课程之外，我每天可以拿出4 ~ 6个小时的自由学习时间，平均每周有30+小时的时间。当然，会有期中考试和期末考试。

放暑假之后，按照小组惯例我会留校学习，整个暑假我会在小组学习。我们有安排好的日程，周一到周六每天有8+小时的时间在小组学习，学习内容由自己安排。周日没有要求，会有一次出游活动。

在整个Gsoc项目期间，我没有其他额外的大型活动安排，自由时间大部分将会用来学习技术，以Gsoc项目的完成为首要任务。

### Educational Experience

2021年9月，我进入西安邮电大学网络工程专业，学习计算机网络相关知识。2021年11月，我成为 XiYou Linux Group 的成员，进行linux相关学习。2022年至今，我学习了Linux系统编程和网络编程，包括Linux系统调用，多线程和多进程，线程池，TCP/IP协议，I/O多路复用、Socket 通信等内容，并从C过渡到C++。

### Code Experience

+ 常见的的数据结构和算法题目。
+ 使用C语言和Linux系统调用完成命令 ls 的实现，支持-a,-l,-s,-t,-r,-i,-R参数自由组合，[code link](https://github.com/Origin-yy/Code_c/tree/main/Group_Task_C/My_ls)。
+ 使用C语言、多进程通信和Linux系统调用完成 shell 的实现，支持管道，重定向，后台运行，cd等操作。[code link](https://github.com/Origin-yy/Code_c/tree/main/Group_Task_C/My_Shell).
+ 使用C，完成多线程通信的生产者消费者问题和哲学家问题，以及线程池的编写,[code link](https://github.com/Origin-yy/Code_c/tree/main/Group_Task_C/Thread)。
+ 使用 socket 、C++线程池、 I/O 多路复用、redis 完成在局域网下的C++多人网络聊天室，具有高稳定高并发的客户端和服务器，支持群聊、增删好友发送文件、离线消息等常见操作，使用 redis 完成数据持久化。[code link](https://github.com/Origin-yy/Code_cc/tree/main/Chatroom).

## Others

Why did you choose this project? What made you interested in our organization?

rFaas通过使用 RDMA 支持对网络资源的高性能、低延迟调用。项目所需要的相关技术符合我的学习方向，并且我对此有着浓厚的兴趣。

What do you wish to accomplish during GSoC?

我希望以此作为我参与开源项目的契机，学到自己感兴趣的技术，提高自己的技术能力和交流沟通协作的能力。同时，我也可以为自己热爱的开源项目做出贡献，

Have you worked with the required technologies before? If yes, then in what scope? Which projects?

没有使用过 IBverbs , Libfabric , RDMA 。在学习过程中对网络编程，TCP/IP，C++，线程池有所了解，我在XiYou Linux Group 中学习到这些，他们可以在我的github中找到。

Did you contribute to open-source projects before? Have you ever made a pull request, helped to fix an issue, or developed a project?

没有，这是我第一次参加开源项目。